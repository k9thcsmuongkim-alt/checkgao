<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Camera Auto-Size</title>
    <style>
        body { background: #000; color: #fff; font-family: monospace; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 5px; }
        
        /* B·∫£ng ƒëi·ªÅu khi·ªÉn */
        #status-panel { width: 100%; max-width: 640px; background: #222; padding: 10px; margin-bottom: 5px; border-bottom: 2px solid #555; }
        .info-line { margin: 5px 0; font-size: 14px; }
        .highlight { color: #00ff00; font-weight: bold; }
        .warn { color: yellow; }
        .err { color: #ff5555; }

        /* M√†n h√¨nh Camera */
        #container { position: relative; width: 100%; max-width: 640px; }
        canvas { width: 100%; height: auto; border: 2px solid #333; display: block; }
        video { display: none; }
        
        /* Khu v·ª±c hi·ªán k·∫øt qu·∫£ th√¥ (Debug) */
        #raw-result { 
            width: 95%; height: 100px; 
            background: #111; border: 1px solid #444; 
            margin-top: 10px; padding: 5px; 
            overflow-y: scroll; font-size: 11px; 
            color: #ddd; white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <div id="status-panel">
        <div class="info-line">TR·∫†NG TH√ÅI: <span id="status-text">ƒêang t·∫£i...</span></div>
        <div class="info-line">MODEL INFO: <span id="model-info" class="warn">Ch∆∞a ƒë·ªçc ƒë∆∞·ª£c...</span></div>
        <div class="info-line">CAMERA: <span id="cam-info">Ch∆∞a b·∫≠t</span></div>
    </div>
    
    <div id="container">
        <canvas id="output"></canvas>
    </div>
    
    <div id="raw-result">K·∫øt qu·∫£ th√¥ s·∫Ω hi·ªán ·ªü ƒë√¢y...</div>
    
    <canvas id="hidden-canvas" style="display:none;"></canvas>
    <video id="webcam" playsinline autoplay muted></video>

    <script>
        var Module = {
            onRuntimeInitialized: function() {
                updateStatus("‚úÖ AI Core ƒë√£ n·∫°p. ƒêang ƒë·ªçc th√¥ng s·ªë...", "highlight");
                initAI();
            },
            locateFile: function(path) { return "edge-impulse-standalone.wasm"; }
        };

        function updateStatus(msg, type='') {
            const el = document.getElementById('status-text');
            el.innerText = msg;
            el.className = type;
        }
    </script>

    <script src="edge-impulse-standalone.js"></script>
    <script src="run-impulse.js"></script>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const hiddenCanvas = document.getElementById('hidden-canvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');
        const rawResultEl = document.getElementById('raw-result');
        const modelInfoEl = document.getElementById('model-info');
        
        var classifier = null;
        // K√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh (s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª± ƒë·ªông)
        var modelWidth = 96;
        var modelHeight = 96; 
        var isReady = false;

        async function initAI() {
            try {
                classifier = new EdgeImpulseClassifier();
                await classifier.init();
                
                // --- T·ª∞ ƒê·ªòNG ƒê·ªåC TH√îNG S·ªê MODEL ---
                // ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ s·ª≠a l·ªói "kh√¥ng nh·∫≠n di·ªán"
                let props = Module.get_properties();
                console.log("Model Props:", props); // Xem log F12 n·∫øu c·∫ßn
                
                // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc chu·∫©n t·ª´ Model
                // (M√£ ngu·ªìn C++ th∆∞·ªùng l∆∞u k√≠ch th∆∞·ªõc ·∫£nh trong input_width/height ho·∫∑c sensors)
                if (props.image_input_width && props.image_input_height) {
                    modelWidth = props.image_input_width;
                    modelHeight = props.image_input_height;
                } else {
                    // N·∫øu kh√¥ng c√≥, th·ª≠ t√≠nh to√°n t·ª´ input_features_count (v√≠ d·ª• 9216 = 96x96x1)
                    // Nh∆∞ng an to√†n nh·∫•t l√† m·∫∑c ƒë·ªãnh 96 ho·∫∑c 160.
                    // B·∫°n c√≥ th·ªÉ s·ª≠a th·ªß c√¥ng s·ªë n√†y n·∫øu bi·∫øt ch√≠nh x√°c model c·ªßa m√¨nh (vd: 320)
                }

                modelInfoEl.innerText = `Input: ${modelWidth}x${modelHeight} | T·∫ßn s·ªë: ${(props.frequency || '?')}Hz`;
                
                // C√†i ƒë·∫∑t canvas ·∫©n ƒë√∫ng k√≠ch th∆∞·ªõc model y√™u c·∫ßu
                hiddenCanvas.width = modelWidth;
                hiddenCanvas.height = modelHeight;

                startCamera();

            } catch (e) {
                updateStatus("L·ªói kh·ªüi t·∫°o AI: " + e.message, "err");
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { facingMode: "environment", width: 640, height: 480 }
                });
                
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    document.getElementById('cam-info').innerText = `${video.videoWidth}x${video.videoHeight}`;
                    updateStatus("üé• ƒêang ch·∫°y nh·∫≠n di·ªán...", "highlight");
                    isReady = true;
                    requestAnimationFrame(loop);
                };
            } catch (err) {
                updateStatus("L·ªói Camera: " + err.message, "err");
            }
        }

        async function loop() {
            // V·∫Ω camera l√™n m√†n h√¨nh
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (isReady && classifier) {
                try {
                    // 1. Resize ·∫£nh v·ªÅ ƒë√∫ng k√≠ch th∆∞·ªõc Model y√™u c·∫ßu
                    hiddenCtx.drawImage(video, 0, 0, modelWidth, modelHeight);
                    
                    // 2. L·∫•y d·ªØ li·ªáu Pixel
                    let imageData = hiddenCtx.getImageData(0, 0, modelWidth, modelHeight);
                    let pixels = imageData.data;
                    
                    // 3. Chuy·ªÉn ƒë·ªïi sang ƒë·ªãnh d·∫°ng Model (RGB Hex Integer)
                    let features = [];
                    for (let i = 0; i < pixels.length; i += 4) {
                        // Edge Impulse th∆∞·ªùng d√πng format: (R << 16) + (G << 8) + B
                        let hex = (pixels[i] << 16) | (pixels[i + 1] << 8) | pixels[i + 2];
                        features.push(hex);
                    }

                    // 4. G·ª≠i ƒëi ph√¢n lo·∫°i
                    let res = classifier.classify(features);

                    // 5. HI·ªÜN K·∫æT QU·∫¢ TH√î (DEBUG)
                    if (res && res.results && res.results.length > 0) {
                        // In k·∫øt qu·∫£ ƒë·∫ßu ti√™n ra √¥ debug ƒë·ªÉ b·∫°n xem
                        let debugText = res.results.map(r => `${r.label}: ${r.value.toFixed(2)}`).join(", ");
                        rawResultEl.innerText = debugText;

                        // 6. V·∫Ω l√™n m√†n h√¨nh
                        res.results.forEach(obj => {
                            // Object Detection (FOMO)
                            if (obj.x !== undefined) {
                                // Quy ƒë·ªïi t·ªça ƒë·ªô
                                let scaleX = canvas.width / modelWidth;
                                let scaleY = canvas.height / modelHeight;
                                
                                let x = obj.x * scaleX;
                                let y = obj.y * scaleY;
                                let w = obj.width * scaleX;
                                let h = obj.height * scaleY;

                                ctx.strokeStyle = '#00FF00'; ctx.lineWidth = 3;
                                ctx.strokeRect(x, y, w, h);
                                ctx.fillStyle = '#00FF00'; ctx.font = '16px Arial';
                                ctx.fillText(obj.label, x, y - 5);
                            } 
                            // Classification (Ph√¢n lo·∫°i ·∫£nh)
                            else if (obj.value > 0.4) { // H·∫° ng∆∞·ª°ng xu·ªëng 0.4 ƒë·ªÉ d·ªÖ th·∫•y
                                ctx.fillStyle = "yellow"; ctx.font = "24px Arial";
                                ctx.fillText(`${obj.label}: ${(obj.value*100).toFixed(0)}%`, 20, 40);
                            }
                        });
                    } else {
                        rawResultEl.innerText = "Kh√¥ng c√≥ k·∫øt qu·∫£ (M·∫£ng r·ªóng)";
                    }

                } catch (e) {
                    rawResultEl.innerText = "L·ªói Loop: " + e.message;
                }
            }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
